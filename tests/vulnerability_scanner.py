"""
Сканер уязвимостей - автоматическое сканирование на известные уязвимости
"""
import requests
import json
from typing import List, Dict
from datetime import datetime

GATEWAY_URL = "http://localhost:8000"
AUTH_URL = f"{GATEWAY_URL}/auth"

class VulnerabilityScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.info = []
        
    def log_vulnerability(self, severity: str, name: str, description: str, 
                         endpoint: str = "", details: str = ""):
        """Логирование найденной уязвимости"""
        vuln = {
            "severity": severity,
            "name": name,
            "description": description,
            "endpoint": endpoint,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        self.vulnerabilities.append(vuln)
        print(f"\n[!] {severity}: {name}")
        print(f"    {description}")
        if endpoint:
            print(f"    Endpoint: {endpoint}")
        if details:
            print(f"    Детали: {details}")
    
    def log_info(self, name: str, description: str):
        """Логирование информационного сообщения"""
        info = {
            "name": name,
            "description": description
        }
        self.info.append(info)
        print(f"[*] INFO: {name} - {description}")
    
    def scan_headers(self):
        """Сканирование заголовков безопасности"""
        print("\n=== Сканирование заголовков безопасности ===")
        
        response = requests.get(f"{GATEWAY_URL}/health")
        headers = response.headers
        
        # Проверка Security Headers
        security_headers = {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": ["DENY", "SAMEORIGIN"],
            "X-XSS-Protection": "1",
            "Strict-Transport-Security": None,  # Любое значение OK
            "Content-Security-Policy": None,
            "Referrer-Policy": None
        }
        
        for header, expected_value in security_headers.items():
            if header not in headers:
                self.log_vulnerability(
                    "MEDIUM",
                    f"Отсутствует заголовок {header}",
                    f"Рекомендуется добавить заголовок {header} для улучшения безопасности",
                    endpoint="/health"
                )
            elif expected_value and isinstance(expected_value, list):
                if headers[header] not in expected_value:
                    self.log_info(
                        f"Заголовок {header}",
                        f"Установлен как '{headers[header]}', рекомендуется '{expected_value[0]}'"
                    )
            elif expected_value and headers[header] != expected_value:
                self.log_info(
                    f"Заголовок {header}",
                    f"Установлен как '{headers[header]}', рекомендуется '{expected_value}'"
                )
        
        if all(h in headers for h in security_headers.keys()):
            print("[✓] Все основные security headers присутствуют")
    
    def scan_endpoints(self):
        """Сканирование эндпоинтов на уязвимости"""
        print("\n=== Сканирование эндпоинтов ===")
        
        endpoints = [
            f"{GATEWAY_URL}/",
            f"{GATEWAY_URL}/health",
            f"{GATEWAY_URL}/docs",
            f"{AUTH_URL}/health",
        ]
        
        for endpoint in endpoints:
            try:
                response = requests.get(endpoint, timeout=5)
                
                # Проверка на раскрытие информации
                if "error" in response.text.lower() and "stack trace" in response.text.lower():
                    self.log_vulnerability(
                        "MEDIUM",
                        "Раскрытие информации об ошибках",
                        f"Эндпоинт {endpoint} возвращает stack trace",
                        endpoint=endpoint
                    )
                
                # Проверка версий в заголовках
                server_header = response.headers.get("Server", "")
                if server_header and any(v in server_header for v in ["nginx/", "Apache/"]):
                    self.log_info(
                        "Информация о сервере",
                        f"Заголовок Server раскрывает версию: {server_header}"
                    )
                
            except Exception as e:
                self.log_info(
                    f"Недоступен эндпоинт {endpoint}",
                    str(e)
                )
    
    def scan_authentication(self):
        """Сканирование механизмов аутентификации"""
        print("\n=== Сканирование аутентификации ===")
        
        # Проверка на слабые пароли
        weak_passwords = ["admin", "password", "123456", "admin123"]
        
        for password in weak_passwords:
            response = requests.post(
                f"{AUTH_URL}/token",
                data={"username": "admin", "password": password},
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                timeout=5
            )
            
            if response.status_code == 200:
                self.log_vulnerability(
                    "HIGH",
                    "Слабый пароль",
                    f"Пароль '{password}' принят системой",
                    endpoint="/auth/token"
                )
        
        # Проверка на отсутствие защиты от brute force
        failed_attempts = 0
        for i in range(5):
            response = requests.post(
                f"{AUTH_URL}/token",
                data={"username": "admin", "password": f"wrong{i}"},
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                timeout=5
            )
            if response.status_code != 200:
                failed_attempts += 1
        
        if failed_attempts == 5:
            response = requests.post(
                f"{AUTH_URL}/token",
                data={"username": "admin", "password": "admin123"},
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                timeout=5
            )
            if response.status_code == 200:
                self.log_info(
                    "Защита от Brute Force",
                    "Система не блокирует множественные неудачные попытки (может быть ожидаемым поведением для демо)"
                )
    
    def scan_cors(self):
        """Сканирование настроек CORS"""
        print("\n=== Сканирование CORS ===")
        
        # Проверка CORS заголовков
        response = requests.options(
            f"{GATEWAY_URL}/health",
            headers={"Origin": "https://evil.com"}
        )
        
        cors_headers = {
            "Access-Control-Allow-Origin": response.headers.get("Access-Control-Allow-Origin"),
            "Access-Control-Allow-Credentials": response.headers.get("Access-Control-Allow-Credentials"),
            "Access-Control-Allow-Methods": response.headers.get("Access-Control-Allow-Methods")
        }
        
        if cors_headers["Access-Control-Allow-Origin"] == "*":
            self.log_vulnerability(
                "MEDIUM",
                "Слабая CORS политика",
                "CORS настроен на разрешение всех источников (*)",
                endpoint="/health"
            )
        elif cors_headers["Access-Control-Allow-Origin"] == "https://evil.com":
            self.log_vulnerability(
                "HIGH",
                "Небезопасная CORS политика",
                "CORS разрешает запросы с любого источника",
                endpoint="/health"
            )
    
    def scan_sensitive_data(self):
        """Поиск утечки чувствительных данных"""
        print("\n=== Поиск чувствительных данных ===")
        
        # Проверка ответов на наличие чувствительной информации
        endpoints = [
            f"{GATEWAY_URL}/docs",
            f"{AUTH_URL}/docs",
        ]
        
        sensitive_patterns = [
            ("password", "Пароли в открытом виде"),
            ("secret", "Секретные ключи"),
            ("api_key", "API ключи"),
            ("token", "Токены"),
            ("database", "Информация о БД"),
        ]
        
        for endpoint in endpoints:
            try:
                response = requests.get(endpoint, timeout=5)
                response_text = response.text.lower()
                
                for pattern, description in sensitive_patterns:
                    if pattern in response_text and "example" not in response_text:
                        # Игнорируем примеры в документации
                        count = response_text.count(pattern)
                        if count > 5:  # Если слишком много упоминаний
                            self.log_info(
                                f"Потенциальная утечка: {description}",
                                f"Найдено в {endpoint}"
                            )
            except:
                pass
    
    def scan_jwt_security(self):
        """Сканирование безопасности JWT"""
        print("\n=== Сканирование JWT ===")
        
        # Получаем токен
        response = requests.post(
            f"{AUTH_URL}/token",
            data={"username": "admin", "password": "admin123"},
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        
        if response.status_code != 200:
            return
        
        token = response.json().get("access_token")
        
        # Декодируем токен (без проверки подписи)
        import base64
        parts = token.split('.')
        if len(parts) == 3:
            try:
                payload = base64.urlsafe_b64decode(parts[1] + '==')
                payload_dict = json.loads(payload)
                
                # Проверка на отсутствие exp
                if "exp" not in payload_dict:
                    self.log_vulnerability(
                        "HIGH",
                        "JWT без времени истечения",
                        "Токен не имеет поля exp (время истечения)",
                        endpoint="/auth/token"
                    )
                
                # Проверка на слабый алгоритм
                header = base64.urlsafe_b64decode(parts[0] + '==')
                header_dict = json.loads(header)
                
                if header_dict.get("alg") == "none":
                    self.log_vulnerability(
                        "CRITICAL",
                        "JWT с алгоритмом None",
                        "Токен использует алгоритм 'none'",
                        endpoint="/auth/token"
                    )
                
                print("[✓] JWT структура проверена")
                
            except Exception as e:
                self.log_info("JWT декодирование", f"Ошибка: {str(e)}")
    
    def generate_report(self):
        """Генерация отчёта о сканировании"""
        print("\n" + "=" * 60)
        print("ОТЧЁТ О СКАНИРОВАНИИ")
        print("=" * 60)
        
        critical = sum(1 for v in self.vulnerabilities if v["severity"] == "CRITICAL")
        high = sum(1 for v in self.vulnerabilities if v["severity"] == "HIGH")
        medium = sum(1 for v in self.vulnerabilities if v["severity"] == "MEDIUM")
        low = sum(1 for v in self.vulnerabilities if v["severity"] == "LOW")
        
        print(f"\nНайдено уязвимостей:")
        print(f"  CRITICAL: {critical}")
        print(f"  HIGH: {high}")
        print(f"  MEDIUM: {medium}")
        print(f"  LOW: {low}")
        print(f"  Информационных сообщений: {len(self.info)}")
        
        # Сохранение отчёта в JSON
        report = {
            "timestamp": datetime.now().isoformat(),
            "vulnerabilities": self.vulnerabilities,
            "info": self.info,
            "summary": {
                "critical": critical,
                "high": high,
                "medium": medium,
                "low": low
            }
        }
        
        with open("vulnerability_report.json", "w", encoding="utf-8") as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"\nОтчёт сохранён в vulnerability_report.json")
        
        return report
    
    def run_all_scans(self):
        """Запуск всех сканирований"""
        print("=" * 60)
        print("СКАНИРОВАНИЕ УЯЗВИМОСТЕЙ")
        print("=" * 60)
        
        self.scan_headers()
        self.scan_endpoints()
        self.scan_authentication()
        self.scan_cors()
        self.scan_sensitive_data()
        self.scan_jwt_security()
        
        return self.generate_report()

if __name__ == "__main__":
    scanner = VulnerabilityScanner()
    scanner.run_all_scans()

